---
title: "Simulation Tutorial"
author: "Lisa DeBruine"
date: 2020-02-13
---

## Packages 

### Julia

```{julia;label=packages;term=true}
using MixedModels        # run mixed models
using MixedModelsSim     # simulation functions for mixed models
using RCall, RData       # call R functions from inside Julia
using DataFrames, Tables, DataFramesMeta # work with data tables
using Random, Statistics # statistical functions
using CSV                # write CSV files
```

### R

```{julia;label=Rlibs}
R"""
library(tidyverse) # for visualisation and data wrangling
""";
```

## Define Custom functions

```{julia;label=scriptvars}
nsims = 1000 # set to a low number for test, high for production
```

### simulate_waldtests

Function for returning p-values for simulated iterations.

```{julia;label=simulate_waldtests}

function simulate_waldtests(
    rng::AbstractRNG,
    n::Integer,
    morig::MixedModel{T};
    β = morig.β,
    σ = morig.σ,
    θ = morig.θ,
    use_threads = false,
) where {T}
    zval, pval, nβ, m = similar(β), similar(β), length(β), deepcopy(morig)
    y₀ = copy(response(m))
    # we need to do for in-place operations to work across threads
    m_threads = [m]
    zval_threads = [zval]
    pval_threads = [pval]

    if use_threads
        Threads.resize_nthreads!(m_threads)
        Threads.resize_nthreads!(zval_threads)
        Threads.resize_nthreads!(pval_threads)
    end

    rnglock = ReentrantLock()
    replicate(n, use_threads=use_threads) do
        mod = m_threads[Threads.threadid()]
        local zval = zval_threads[Threads.threadid()]
        local pval = pval_threads[Threads.threadid()]
        lock(rnglock)
        mod = simulate!(rng, mod, β = β, σ = σ, θ = θ)
        unlock(rnglock)
        refit!(mod)
        ct = coeftable(mod)
        (
         beta = ct.cols[1],
         se = ct.cols[2],
         z = ct.cols[3],
         p = ct.cols[4],
        )
    end
end

```

### ggplot_betas

```{julia;label=ggplot_betas}

function ggplot_betas(sim, colnames, figname = "betas.png") 
    beta_df = reduce(hcat, columntable(sim).beta)' |> DataFrame;
    coln = ncol(beta_df);
    if isa(colnames, Nothing)
        colnames = string.("Eff", 1:coln);
    end
    rename!(beta_df, colnames);
    @rput beta_df;
    @rput figname;

    R"""
        beta_df %>%
            gather(var, val, 1:ncol(.)) %>%
            ggplot(aes(val, color = var)) +
            geom_density(show.legend = FALSE) +
            facet_wrap(~var, scales = "free")

        ggsave(figname)
    """;

    "![]("*figname*")"
end

```

### power 

```{julia;label=power}

function power_table(sim, colnames, alpha = 0.05)
    pvals = columntable(sim).p;

    coln = length(pvals[1]);
    if isa(colnames, Nothing)
        colnames = string.("Eff", 1:coln)
    end
    
    power = Dict();
    for i in 1:coln
        power[colnames[i]] = mean(getindex.(pvals,i) .< alpha)
    end
    
    sort(power)
end


```

# Existing Data

Load existing data from this morning's tutorial. Set the contrasts and run model 4.

```{julia;label=load-data}

# load data
# kb07 = load("data/kb07_exp2_rt.rds");
kb07 = MixedModels.dataset("kb07");

# set contrasts
const HC = HelmertCoding();
const contrasts = Dict(:spkr => HC, :prec => HC, :load=> HC);

# define formula
f4 = @formula(rt_trunc ~ 1 + spkr+prec+load + (1|subj) + (1+prec|item));

# fit model
m4 = fit(MixedModel, f4, kb07, contrasts=contrasts)

```

## Bootstrap estimates

Use the `simulate_waldtests()` function to run `j nsims` iterations of data sampled 
using the parameters from `m4`. 
Set up a random seed to make the simulation reproducible. You can use your favourite number.

```{julia}
# seed for reproducibility
rnd = MersenneTwister(8675309);

# run 1000 iterations
sim4 = simulate_waldtests(rnd, nsims, m4, use_threads = true);

```

Put betas into a data frame and send to R for plotting in ggplot.

```{julia; results="raw"}

m4_names = coefnames(m4)

ggplot_betas(sim4, m4_names);

```

![](betas.png)


## Power calculation

```{julia}

power_table(sim4, m4_names)

```

## Change parameters

Let's say we want to check our power to detect effects of spkr, prec, and load 
that are half the size of our pilot data.

```{julia}

newβ = m4.β
newβ[2:4] = m4.β[2:4]/2

sim4_half = simulate_waldtests(rnd, nsims, m4, β = newβ, use_threads = true);

power_table(sim4_half, m4_names)

```


# Simulating Data from Scratch


## simdat

Custom function for simulating data in julia.

This is for a design with a between-subjects factor of `age` (O or Y) and 
`sub_n` subjects per group.
Each subject responed to `item_n` items. 
Create a simulated data structure with `simdat(sub_n, item_n)`.

```{julia;label=simdat}

function simdat(sub_n, item_n) 

    ages = vcat(
        repeat(["O"], sub_n),
        repeat(["Y"], sub_n)
    );

    subject = (subj = nlevels(sub_n*2), 
            age = ages);

    item = (item = nlevels(item_n, "I"),)

    design = factorproduct(item, subject) |>
        DataFrame;

    dat = @linq design |>
        transform(dv = randn(sub_n*2*item_n)) |> 
        pooled!
end

#dat = simdat(30, 20);

```

## Set up design with R

Or you can use `sim_design()` in {faux} to set up a data structure in R. 
Don't worry about setting means and SDs, we'll simulate null effects and 
add fixed and random effects structures directly to  `simulate_waldtests`.

```{julia;label=design-r}

R"""

dat <- faux::sim_design(
    within = list(item = faux::make_id(20, "I")), 
    between = list(age = c("O", "Y")), 
    n = 30,
    dv = "dv", 
    id = "subj",
    plot = FALSE, 
    long = TRUE
)

""";

dat = rcopy(R"dat");

```

## Set up model

```{julia;label=model}

f1 = @formula dv ~ 1 + age + (1|item) + (1|subj);
m1 = fit(MixedModel, f1, dat)

m1.β
m1.σ
m1.θ

```

## Simulate

* Set a seed for reproducibility
* specify new β, σ, and θ

```{julia;label=sim}

rnd = MersenneTwister(8675309);

new_beta = [0, 0.25]
new_sigma = 1.0
new_theta = [0.2, 0.2]

sim1 = simulate_waldtests(rnd, nsims, m1, 
                        β = new_beta, 
                        σ = new_sigma, 
                        θ = new_theta,
                        use_threads = true);

```


## Explore simulation output


```{julia;results="hidden"}

m1_names = ["int", "age"]
ggplot_betas(sim1, m1_names, "simbetas.png");

```

![](simbetas.png)


## Power

```{julia;label=power}

power_table(sim1, m1_names)

```

## Write simulation data to a csv file

```{julia}

sim1 |> CSV.write("sim1.csv") 

```

## Write a function to vary something

```{julia}

function mysim(sub_n, item_n, 
               nsims = 1000, 
               beta  = [0, 0],
               sigma = 1, 
               theta = [1, 1],
               seed = convert(Int64, round(rand()*1e8))
               )
    @rput sub_n;
    @rput item_n;

    # generate data
    R"""
        dat <- faux::sim_design(
            within = list(item = faux::make_id(item_n, "I")), 
            between = list(age = c("O", "Y")), 
            n = sub_n,
            dv = "dv", 
            id = "subj",
            plot = FALSE, 
            long = TRUE
        )
    """;

    dat = rcopy(R"dat");

    # set up model
    f = @formula dv ~ 1 + age + (1|item) + (1|subj);
    m = fit(MixedModel, f, dat)

    # run simulation
    rnd = MersenneTwister(seed);

    simulate_waldtests(
        rnd, nsims, m, 
        β = beta, 
        σ = sigma, 
        θ = theta, 
        use_threads = true
    );
end

```


```{julia}

s20_10 = mysim(20, 10, 1000, [0, 0.5])

power_table(s20_10, m1_names)

s20_20 = mysim(20, 20, 1000, [0, 0.5])

power_table(s20_20, m1_names)

s20_30 = mysim(20, 20, 1000, [0, 0.5])

power_table(s20_30, m1_names)

```
